define(["jquery", "lib/components/base/modal"], function ($, Modal) {
  return class FieldFabric {
    #self;
    constructor(self) {
      this.#self = self;
    }

    create(id) {
      return new this.#fieldInstance(this.#self, id);
    }

    #fieldInstance = class {
      #self;
      #fieldContainer;
      #htmlFieldHighlighting;
      #fieldElement;
      #label = false;
      #type;
      isCustomField = false;

      constructor(self, id) {
        this.#self = self;
        const { dom } = self;
        this.id = id;

        let name;
        if (this.#isNumeric(id)) {
          name = `CFV[${id}]`;
          this.isCustomField = true;
        } else {
          name = `lead[${id.toUpperCase()}]`;
        }
        this.name = name;

        // Пытаемся найти поле разными способами
        this.#fieldContainer = dom.get(`[data-id="${id}"]`);

        if (this.#fieldContainer) {
          // Определяем тип поля по классам контейнера
          if (
            this.#fieldContainer.classList.contains(
              "linked-form__field-multiselect",
            )
          ) {
            this.#type = "multiselect";
          } else if (
            this.#fieldContainer.classList.contains(
              "linked-form__field-legal_entity",
            )
          ) {
            this.#type = "legal_entity";
          } else if (
            this.#fieldContainer.classList.contains("linked-form__field-radio")
          ) {
            this.#type = "radio";
          } else {
            this.#type = "default";
            // Для обычных полей ищем input внутри контейнера
            this.#fieldElement = this.#fieldContainer.querySelector(
              "input, textarea, select",
            );
          }
        } else {
          // Если не нашли по data-id, ищем по name и другим атрибутам
          this.#fieldElement = this.#findFieldElementByName(name);
          if (!this.#fieldElement) {
            // Для специальных типов полей ищем по структуре
            this.#fieldContainer = this.#findSpecialFieldContainer(id);
            if (this.#fieldContainer) {
              if (
                this.#fieldContainer.classList.contains(
                  "linked-form__field-legal_entity",
                )
              ) {
                this.#type = "legal_entity";
              } else if (
                this.#fieldContainer.classList.contains(
                  "linked-form__field-radio",
                )
              ) {
                this.#type = "radio";
              } else {
                this.#type = "default";
              }
            } else {
              this.#type = "default";
            }
          } else {
            this.#type = "default";
          }
        }

        try {
          this.#htmlFieldHighlighting = this.element.closest(
            ".linked-form__field",
          );
          if (this.#htmlFieldHighlighting === null) {
            if (window.pizdaFields === undefined) {
              window.pizdaFields = [];
            }
            window.pizdaFields.push(this.id);
          }
        } catch (error) {
          console.error("Error in FieldFabric.js#getFromAmoObject", error);
          alert(this.id);
        }
      }

      #getFromAmoObject() {
        const fieldKey = this.name;
        const attributes = APP.data.current_card.model.attributes;
        const result = {};

        // Ищем все ключи, которые начинаются с fieldKey
        for (const key in attributes) {
          if (key.startsWith(fieldKey)) {
            const value = attributes[key];

            // Если ключ точно равен fieldKey - это одиночное поле
            if (key === fieldKey) {
              return value; // Возвращаем просто значение
            }

            // Если ключ содержит дополнительные скобки - это мультисписок
            // Извлекаем внутренний ключ из формата CFV[ID][SUB_ID]
            const match = key.match(/\[(\d+)\]$/);
            if (match) {
              const subKey = match[1];
              result[subKey] = value;
            }
          }
        }

        // Если нашли мультизначения, возвращаем объект
        if (Object.keys(result).length > 0) {
          return result;
        }

        // Если ничего не нашли
        return null;
      }

      filterEmptyFields(data) {
        // Если данные - строка, число или другой примитив, возвращаем как есть
        if (data === null || data === undefined || typeof data !== "object") {
          return data;
        }

        // Если это массив (на всякий случай)
        if (Array.isArray(data)) {
          return data.filter(
            (item) => item !== "" && item !== null && item !== undefined,
          );
        }

        // Если это объект (мультисписок)
        const filtered = {};
        for (const [key, value] of Object.entries(data)) {
          // Пропускаем пустые строки, null и undefined
          if (value !== "" && value !== null && value !== undefined) {
            filtered[key] = value;
          }
        }

        return filtered;
      }

      #findFieldElementByName(name) {
        const { dom } = this.#self;

        // Прямой поиск по name
        let element = dom.get(`[name="${name}"]`);
        if (element) return element;

        // Для полей с паттерном имени
        if (name.startsWith("CFV[")) {
          const pattern = `[name*="${name}"]`;
          const elements = dom.getAll(pattern);
          if (elements.length > 0) {
            return elements[0];
          }
        }

        return null;
      }

      #findSpecialFieldContainer(id) {
        const { dom } = this.#self;

        // Поиск по data-id
        let container = dom.get(`[data-id="${id}"]`);
        if (container) {
          return container;
        }

        // Поиск radio полей по name
        const radioInputs = dom.getAll(`input[name="CFV[${id}]"]`);
        if (radioInputs.length > 0) {
          return radioInputs[0].closest(".linked-form__field-radio");
        }

        // Поиск legal_entity полей
        const legalEntityContainers = dom.getAll(
          ".linked-form__field-legal_entity",
        );
        for (const container of legalEntityContainers) {
          const inputs = container.querySelectorAll('input[name*="CFV"]');
          for (const input of inputs) {
            if (input.name.includes(`CFV[${id}]`)) {
              return container;
            }
          }
        }

        return null;
      }

      get type() {
        return this.#type;
      }

      getTabElement(hiddenTabsCount) {
        let elem;
        if (this.#type === "default") {
          elem = this.#fieldElement || this.#fieldContainer;
        } else {
          elem = this.#fieldContainer;
        }

        try {
          function getTabId(elem) {
            if (!elem) return null;

            if (/^lead\[[A-Z_]+]$/.test(elem?.name)) {
              return "default";
            }

            // Поиск родительского элемента с классом
            let currentElem = elem;
            while (
              currentElem &&
              !currentElem.classList.contains("js-cf-group-wrapper")
            ) {
              currentElem = currentElem.parentElement;
            }

            if (!currentElem) {
              return null;
            }

            return currentElem.getAttribute("data-id");
          }

          function tryGetTabNotContext(tabId) {
            return document.querySelector(`.js-card-tab[data-id="${tabId}"]`);
          }

          const tabId = getTabId(elem);
          if (!tabId) {
            if (!this.filled) {
              hiddenTabsCount++;
            }
            return [null, hiddenTabsCount];
          }

          const tab = tryGetTabNotContext(tabId);
          if (tab === null) {
            if (!this.filled) {
              hiddenTabsCount++;
            }
            return [
              document.querySelector(`#linked_context_${tabId}`),
              hiddenTabsCount,
            ];
          } else {
            return [tab, hiddenTabsCount];
          }
        } catch (error) {
          console.error("Ошибка при получении вкладки:", error, elem);
          return [null, hiddenTabsCount];
        }
      }

      after(element) {
        const target = this.#getInsertionTarget();
        if (target) {
          target.after(element);
        }
      }

      #getInsertionTarget() {
        switch (this.#type) {
          case "multiselect":
            return this.#fieldContainer?.querySelector(
              ".linked-form__field__value",
            );
          case "legal_entity":
            return this.#fieldContainer?.querySelector(".legal-entity");
          case "radio":
            return this.#fieldContainer?.querySelector(
              ".linked-form__field__value",
            );
          case "default":
            return (
              this.#fieldElement ||
              this.#fieldContainer?.querySelector(".linked-form__field__value")
            );
          default:
            return this.#fieldContainer;
        }
      }

      #getMultiSelectValues() {
        if (!this.#fieldContainer) return [];

        const selectedCheckboxes = this.#fieldContainer.querySelectorAll(
          "input.js-item-checkbox:checked",
        );
        return Array.from(selectedCheckboxes).map((checkbox) => ({
          value: checkbox.value,
          text: checkbox
            .closest(".checkboxes_dropdown__item")
            .querySelector(".checkboxes_dropdown__label_title")
            .textContent.trim(),
        }));
      }

      #getLegalEntityValues() {
        if (!this.#fieldContainer) return {};

        const legalEntity = this.#fieldContainer.querySelector(".legal-entity");
        if (!legalEntity) return {};

        const inputs = legalEntity.querySelectorAll(
          'input[class*="js-legal-entity"]',
        );
        const values = {};

        inputs.forEach((input) => {
          if (input.disabled) return;

          const fieldName = this.#extractLegalEntityFieldName(input.className);
          if (fieldName && input.value.trim() !== "") {
            values[fieldName] = input.value;
          }
        });

        return values;
      }

      #getRadioValue() {
        if (!this.#fieldContainer) return "";

        const checkedRadio = this.#fieldContainer.querySelector(
          'input[type="radio"]:checked',
        );
        if (!checkedRadio) return "";

        // Получаем текст метки для выбранного radio
        const label = checkedRadio.closest("label");
        const textElement = label?.querySelector(".control-radio-label-text");
        const text = textElement ? textElement.textContent.trim() : "";

        return {
          value: checkedRadio.value,
          text: text,
        };
      }

      #extractLegalEntityFieldName(className) {
        const match = className.match(/js-legal-entity-(\w+)/);
        return match ? match[1] : null;
      }

      get container() {
        return this.#htmlFieldHighlighting;
      }

      get label() {
        if (!this.#label)
          this.#label = this.#htmlFieldHighlighting.querySelector(
            ".linked-form__field__label",
          );
        return this.#label;
      }

      get filled() {
        return (
          this.value !== "" && this.value !== null && this.value !== undefined
        );
      }

      #getCurrentValue() {
        switch (this.#type) {
          case "multiselect":
            const multiValues = this.#getMultiSelectValues();
            return multiValues.length > 0 ? JSON.stringify(multiValues) : "";

          case "legal_entity":
            const legalEntityValues = this.#getLegalEntityValues();
            const hasValues = Object.values(legalEntityValues).some(
              (val) => val.trim() !== "",
            );
            return hasValues ? JSON.stringify(legalEntityValues) : "";

          case "radio":
            const radioValue = this.#getRadioValue();
            return radioValue ? JSON.stringify(radioValue) : "";

          case "default":
            if (this.#fieldElement) {
              return this.#fieldElement.value;
            }
            // Для полей без прямого input (например, текстовые поля)
            const valueElement = this.#fieldContainer?.querySelector(
              ".linked-form__field__value",
            );
            return valueElement ? valueElement.textContent.trim() : "";

          default:
            return "";
        }
      }

      get value() {
        const currentValue = this.#getCurrentValue();
        if (currentValue === "") {
          let valueFromAmo = this.filterEmptyFields(this.#getFromAmoObject());
          return Object.keys(valueFromAmo).length === 0
            ? ""
            : JSON.stringify(valueFromAmo);
        } else {
          return currentValue;
        }
      }

      // Дополнительные методы для удобства
      get rawValue() {
        switch (this.#type) {
          case "multiselect":
            return this.#getMultiSelectValues();
          case "legal_entity":
            return this.#getLegalEntityValues();
          case "radio":
            return this.#getRadioValue();
          case "default":
            return this.value;
          default:
            return null;
        }
      }

      get element() {
        return this.#fieldContainer || this.#fieldElement;
      }

      // Получение всех input элементов legal_entity
      get legalEntityInputs() {
        if (this.#type !== "legal_entity") return [];

        const legalEntity =
          this.#fieldContainer?.querySelector(".legal-entity");
        if (!legalEntity) return [];

        return Array.from(
          legalEntity.querySelectorAll('input[class*="js-legal-entity"]'),
        ).filter((input) => !input.disabled);
      }

      // Получение всех radio вариантов
      get radioOptions() {
        if (this.#type !== "radio") return [];

        if (!this.#fieldContainer) return [];

        const radioInputs = this.#fieldContainer.querySelectorAll(
          'input[type="radio"]',
        );
        const options = [];

        radioInputs.forEach((radio) => {
          const label = radio.closest("label");
          const textElement = label?.querySelector(".control-radio-label-text");
          const text = textElement ? textElement.textContent.trim() : "";

          options.push({
            value: radio.value,
            text: text,
            checked: radio.checked,
            element: radio,
          });
        });

        return options;
      }

      // Получение значения конкретного поля legal_entity
      getLegalEntityFieldValue(fieldName) {
        if (this.#type !== "legal_entity") return "";

        const legalEntity =
          this.#fieldContainer?.querySelector(".legal-entity");
        if (!legalEntity) return "";

        const input = legalEntity.querySelector(
          `.js-legal-entity-${fieldName}`,
        );
        return input ? input.value : "";
      }

      /**
       * Проверяет, является ли строка числом
       */
      #isNumeric(str) {
        if (typeof str !== "string" || str.length === 0) return false;
        return !isNaN(str) && isFinite(str);
      }

      highlight() {
        const { options } = this.#self;

        this.#htmlFieldHighlighting.classList.add(
          `emfy-${options.get("module")}-transition-03s`,
        );
        this.#htmlFieldHighlighting.classList.add(
          `emfy-${options.get("module")}-highlight-field`,
        );

        setTimeout(() => {
          this.#htmlFieldHighlighting.classList.remove(
            `emfy-${options.get("module")}-highlight-field`,
          );
        }, 1000);

        setTimeout(() => {
          this.#htmlFieldHighlighting.classList.remove(
            `emfy-${options.get("module")}-transition-03s`,
          );
        }, 1350);
      }

      // Метод для отладки
      debug() {
        console.log("Field debug info:", {
          id: this.id,
          type: this.#type,
          name: this.name,
          container: this.#fieldContainer,
          element: this.#fieldElement,
          value: this.value,
          rawValue: this.rawValue,
          filled: this.filled,
          legalEntityInputs:
            this.#type === "legal_entity" ? this.legalEntityInputs : "N/A",
          radioOptions: this.#type === "radio" ? this.radioOptions : "N/A",
        });
      }
    };
  };
});
