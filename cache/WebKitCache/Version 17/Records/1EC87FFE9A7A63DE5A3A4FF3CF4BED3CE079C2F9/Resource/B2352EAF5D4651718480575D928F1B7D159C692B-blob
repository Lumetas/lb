define(["jquery", "lib/components/base/modal"], function ($, Modal) {
  return class ChannelManager {
    constructor(self) {
      this.#self = self;
      this.#instances = new Map();
      this.#currentId = null;
    }

    #text = {
      newChannel: "Новый канал",
      channel: "Канал",
      delete: "Удалить",
      edit: "Редактировать",
      managers: "Менеджеры",
      pipelines: "Воронки и этапы",
      requiredFields: "Обязательные поля",
      addChannel: "Добавить канал",
      title: "Настройка каналов",
      channelList: "Список каналов",
      createChannel: "Создать канал",
      save: "Сохранить",
      cancel: "Отмена",
      noChannels: "Нет созданных правил.",
      noChannelsDescription: "Нажмите на кнопку выше, чтобы добавить правило.",
      requiredFieldsDescription:
        "Укажите в правилах поля, без заполнения которых сделку нельзя будет сдвинуть.\nОпределите воронки и этапы, когда они становятся обязательными.",
      choosePipelinesStages: "Выберите воронки и этапы",
      noPipelinesAvailable: "Нет доступных воронок",
      pipelinesStages: "Воронки и этапы",
      fields: "Поля",
      choose: "выбрать",
      managersNotAvailable: "Компонент выбора менеджеров не доступен",
      baseFieldsGroup: "Базовые поля",
      customFields: "Доп. поля",
      fieldsNotSet: "Не заданы",
      managersNotAssigned: "Не назначены",
      managersCount: "менеджеров",
      errorLoadingPipelines: "Ошибка загрузки воронок",
      mainPipeline: "Основная воронка",
      additionalPipeline: "Доп. воронка",
      primaryContact: "Первичный контакт",
      negotiations: "Переговоры",
      decisionMaking: "Принятие решения",
      analysis: "Анализ",
      closing: "Закрытие",
      pipeline: "Воронка",
      stage: "Этап",
      manager: "Менеджер",
      baseFields: {
        name: "Название",
        budget: "Бюджет",
        pipeline: "Воронка",
        stage: "Этап",
        responsible: "Ответственный",
        tags: "Теги",
        lossReason: "Причина отказа",
        createdAt: "Дата создания",
        updatedAt: "Дата изменения",
        closedAt: "Дата закрытия",
        period: "Срок",
        contact: "Контактное лицо",
        source: "Источник",
      },
    };

    #self;
    #pipelineAndFieldSection;
    #managersSection;
    #instances;
    #cachedPipelines;
    #currentId;
    #sectionToggler;
    #fieldsCache;
    #currentModalData = null;
    #fieldsCachePromise;
    #pipelineCachePromise;

    #generateIdForItem() {
      return `channel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    async #getFieldsCache() {
      const LIMIT = 250;

      const baseItems = [
        { id: "name", option: this.#text.baseFields.name, group: "base" },
        { id: "price", option: this.#text.baseFields.budget, group: "base" },
        {
          id: "pipeline_id",
          option: this.#text.baseFields.pipeline,
          group: "base",
        },
        { id: "status_id", option: this.#text.baseFields.stage, group: "base" },
        {
          id: "responsible_user_id",
          option: this.#text.baseFields.responsible,
          group: "base",
        },
        { id: "tags", option: this.#text.baseFields.tags, group: "base" },
        {
          id: "loss_reason_id",
          option: this.#text.baseFields.lossReason,
          group: "base",
        },
        {
          id: "created_at",
          option: this.#text.baseFields.createdAt,
          group: "base",
        },
        {
          id: "updated_at",
          option: this.#text.baseFields.updatedAt,
          group: "base",
        },
        {
          id: "closed_at",
          option: this.#text.baseFields.closedAt,
          group: "base",
        },
      ];

      // 2) Тянем все кастомные поля сделки из v4 (пагинация)
      const customFields = [];
      for (let page = 1; ; page++) {
        const url = `${location.origin}/api/v4/leads/custom_fields?limit=${LIMIT}&page=${page}`;
        const res = await fetch(url, { credentials: "include" });
        if (!res.ok)
          throw new Error(`Failed to load custom fields: ${res.status}`);
        const data = await res.json();
        const chunk =
          (data && data._embedded && data._embedded.custom_fields) || [];
        customFields.push(...chunk);
        if (chunk.length < LIMIT) break;
      }

      // 3) Формируем группы и словарь items
      const groups = {
        base: {
          id: "base",
          name: this.#text.baseFieldsGroup,
          items: [],
          items_ids: [],
        },
        custom: {
          id: "custom",
          name: this.#text.customFields,
          items: [],
          items_ids: [],
        },
      };
      const items = {};

      // Базовые
      for (const it of baseItems) {
        items[it.id] = it;
        groups.base.items.push(it);
        groups.base.items_ids.push(it.id);
      }

      // Кастомные (берём имя поля и его numeric id из API v4)
      for (const cf of customFields) {
        const id = String(cf.id);
        const item = { id, option: String(cf.name || ""), group: "custom" };
        items[id] = item;
        groups.custom.items.push(item);
        groups.custom.items_ids.push(id);
      }

      this.#fieldsCache = { groups, items };
      return this.#fieldsCache;
    }

    async #getPipelineCache() {
      try {
        const LIMIT = 250;
        const base = `${location.origin}/api/v4/leads/pipelines`;
        const pipelines = [];

        let page = 1;
        while (true) {
          const url = `${base}?limit=${LIMIT}&page=${page}&with=statuses`;
          const res = await fetch(url, { credentials: "include" });
          if (!res.ok)
            throw new Error(`Failed to load pipelines: ${res.status}`);
          const data = await res.json();
          const chunk =
            (data && data._embedded && data._embedded.pipelines) || [];
          pipelines.push(...chunk);
          if (chunk.length < LIMIT) break;
          page += 1;
        }

        const map = {};
        for (const p of pipelines) {
          let statuses = (p._embedded && p._embedded.statuses) || [];

          if (!statuses || !statuses.length) {
            const stUrl = `${base}/${p.id}/statuses?limit=${LIMIT}`;
            const stRes = await fetch(stUrl, { credentials: "include" });
            if (stRes.ok) {
              const stData = await stRes.json();
              statuses =
                (stData && stData._embedded && stData._embedded.statuses) || [];
            }
          }

          const statusesMap = {};
          for (const s of statuses) {
            statusesMap[s.id] = { id: Number(s.id), name: String(s.name) };
          }

          map[p.id] = {
            id: Number(p.id),
            name: String(p.name),
            statuses: statusesMap,
          };
        }

        this.#cachedPipelines = map;
        return this.#cachedPipelines;
      } catch (error) {
        console.error("Failed to load pipelines:", error);
        this.#cachedPipelines = this.#getMockPipelines();
        return this.#cachedPipelines;
      }
    }

    // Метод для ожидания завершения инициализации кэшей
    async #ensureCacheInitialized() {
      if (!this.#fieldsCache) {
        this.#fieldsCache = await this.#fieldsCachePromise;
      }
      if (!this.#cachedPipelines) {
        this.#cachedPipelines = await this.#pipelineCachePromise;
      }
    }

    #deepClone(obj) {
      if (obj === null || typeof obj !== "object") return obj;
      if (obj instanceof Date) return new Date(obj);
      if (obj instanceof Array) return obj.map((item) => this.#deepClone(item));

      const cloned = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          cloned[key] = this.#deepClone(obj[key]);
        }
      }
      return cloned;
    }

    async render(settings = {}) {
      const self = this.#self;
      const { utils, dom, options } = self;
      // Ожидаем завершения инициализации кэшей
      await this.#ensureCacheInitialized();

      const id = this.#generateId();
      const channelData = this.#parseSettings(settings);

      // Создаем основной контейнер
      const container = dom.add("div");
      container.classList.add(`emfy-${options.get("module")}-settings-block`);
      container.classList.add(`emfy-${options.get("module")}-channel-manager`);

      // Добавляем описание обязательных полей
      const descriptionSection = dom.add("div");
      descriptionSection.className = `emfy-${options.get("module")}-description-section`;
      descriptionSection.style.cssText = `
      margin-bottom: 20px;
      padding: 15px;
      background: var(--palette-background-default);
      border-radius: 5px;
      width: 520px;
      box-sizing: border-box;
      border: 1px solid var(--palette-border-default);
    `;

      const descriptionTitle = dom.add("div");
      descriptionTitle.textContent = this.#text.requiredFields;
      descriptionTitle.style.cssText = `
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--palette-text-primary);
    `;

      const descriptionText = dom.add("div");
      descriptionText.textContent = this.#text.requiredFieldsDescription;
      descriptionText.style.cssText = `
      color: var(--palette-text-secondary);
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-line;
    `;

      descriptionSection.appendChild(descriptionTitle);
      descriptionSection.appendChild(descriptionText);
      container.appendChild(descriptionSection);

      // Преобразуем данные для SortableSettings
      const sortableData = this.#convertToSortableFormat(channelData);

      // Создаем SortableSettings
      const sortableSettings = this.#self.sortableSettings(
        this.#self,
        sortableData,
        this.#renderModalHandler.bind(this),
        this.#parseModalDataHandler.bind(this),
        this.#getPresentSettings(),
        true, // draggable
        false, // withGroups
      );

      const sortableContainer = sortableSettings.renderSortableSettings();
      container.appendChild(sortableContainer);

      // Добавляем сообщение о пустом состоянии
      if (channelData.length === 0) {
        this.#showEmptyState(container);
      }

      this.createDelitionsButtons(
        sortableContainer.querySelector("ul.sortable-list.ui-sortable"),
      );

      // Устанавливаем колбэки
      sortableSettings.setCallbacks({
        update: () => {
          this.createDelitionsButtons(
            sortableContainer.querySelector("ul.sortable-list.ui-sortable"),
          );
          this.#onSettingsUpdate(id, sortableSettings);
          utils.useSaveButton("open");
          // Обновляем отображение пустого состояния
          const currentData = sortableSettings.getSettings();
          if (currentData.length === 0) {
            this.#showEmptyState(container);
          } else {
            this.#hideEmptyState(container);
          }
        },
        generateIdForItem: this.#generateIdForItem.bind(this),
      });

      // Устанавливаем тексты
      sortableSettings.setText({
        addNewItem: this.#text.createChannel,
      });

      this.#instances.set(id, {
        container,
        sortableSettings,
        channels: channelData,
      });

      this.#currentId = id;
      return { settingsBlock: container, id: id };
    }

    createDelitionsButtons(ul) {
      ul.querySelectorAll("li").forEach((li) => {
        this.createDeleteButton(li);
      });
    }

    createDeleteButton(li) {
      const { dom, options, ui } = this.#self;
      const id = li.getAttribute("data-index");

      function waitForElement(selector) {
        return new Promise((resolve, reject) => {
          // Сначала проверяем, может элемент уже есть
          const element = document.querySelector(selector);
          if (element) {
            resolve(element);
            return;
          }

          const observer = new MutationObserver((mutations, obs) => {
            const element = document.querySelector(selector);
            if (element) {
              obs.disconnect();
              resolve(element);
            }
          });

          observer.observe(document.body, {
            childList: true,
            subtree: true,
          });
        });
      }

      const windowOpener = li.querySelector(".three_lines");
      const need_fill_fields = document.querySelector(
        ".emfy-need_fill_fields_private",
      );
      const openWidnow = () => {
        need_fill_fields.classList.add(
          `emfy-${options.get("module")}-settings-modal-display-none`,
        );
        console.log(need_fill_fields.classList);
        waitForElement(
          ".emfy-need_fill_fields_private-settings-block .delete-button",
        ).then((element) => {
          setTimeout(() => {
            element.click();
          }, 50);
          console.log(element);
          setTimeout(() => {
            need_fill_fields.classList.remove(
              `emfy-${options.get("module")}-settings-modal-display-none`,
            );
            console.log(need_fill_fields.classList);
          }, 150);
        });
        windowOpener.click();
      };

      const btn = document.createElement("button");
      btn.style.cssText = `
      right: 20px;
      position: relative;
    `;
      btn.className = `emfy-${options.get("module")}-channel-delete-button`;
      btn.innerHTML = ui.deleteButton;
      btn.addEventListener("click", () => {
        openWidnow();
      });

      if (
        li.querySelector(`.emfy-${options.get("module")}-channel-delete-button`)
      ) {
        li.querySelector(
          `.emfy-${options.get("module")}-channel-delete-button`,
        ).remove();
      }
      li.querySelector(".active_selector div").style.right = "30px";
      li.querySelector(".active_selector").appendChild(btn);
      return btn;
    }

    #showEmptyState(container) {
      const { dom, options } = this.#self;

      // Удаляем существующее пустое состояние
      const existingEmptyState = container.querySelector(
        `.emfy-${options.get("module")}-empty-state`,
      );
      if (existingEmptyState) {
        existingEmptyState.remove();
      }

      const emptyState = dom.add("div");
      emptyState.className = `emfy-${options.get("module")}-empty-state`;
      emptyState.style.cssText = `
      text-align: center;
      width: 520px;
      box-sizing: border-box;
      padding: 40px 20px;
      color: var(--palette-text-secondary);
      background: var(--palette-background-default);
      border-radius: 5px;
      border: 1px solid var(--palette-border-default);
      margin-top: 20px;
    `;

      const emptyText = dom.add("div");
      emptyText.textContent = this.#text.noChannels;
      emptyText.style.cssText = `
      font-size: 16px;
      margin-bottom: 8px;
      color: var(--palette-text-primary);
    `;

      const emptyDescription = dom.add("div");
      emptyDescription.textContent = this.#text.noChannelsDescription;
      emptyDescription.style.cssText = `
      font-size: 14px;
      color: var(--palette-text-secondary);
    `;

      emptyState.appendChild(emptyText);
      emptyState.appendChild(emptyDescription);
      container.appendChild(emptyState);
    }

    #hideEmptyState(container) {
      const { options } = this.#self;
      const emptyState = container.querySelector(
        `.emfy-${options.get("module")}-empty-state`,
      );
      if (emptyState) {
        emptyState.remove();
      }
    }

    async getData(id = null) {
      // Ожидаем завершения инициализации кэшей
      await this.#ensureCacheInitialized();

      if (id === null) {
        id = this.#currentId;
      }
      if (!this.#instances.has(id)) {
        throw new Error(`ChannelManager: instance with id ${id} not found`);
      }

      const instance = this.#instances.get(id);
      const sortableData = instance.sortableSettings.getSettings();
      return this.#convertFromSortableFormat(sortableData);
    }

    #generateId() {
      return `channel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    #parseSettings(settings) {
      const channels = settings.channels || {};

      return Object.entries(channels).map(([name, config]) => ({
        id: this.#generateId(),
        name,
        managers: config.managers || [],
        pipelines: config.pipelines || [],
        requiredFields: config.requiredFields || [],
        active: config.active !== undefined ? config.active : true,
      }));
    }

    #convertToSortableFormat(channels) {
      return channels.map((channel) => ({
        id: channel.id,
        name: channel.name,
        managers: channel.managers,
        pipelines: channel.pipelines,
        requiredFields: channel.requiredFields,
        active: channel.active !== undefined ? channel.active : true,
      }));
    }

    #convertFromSortableFormat(sortableData) {
      const result = {
        channels: {},
      };

      sortableData.forEach((channel) => {
        result.channels[channel.name] = {
          managers: channel.managers,
          pipelines: channel.pipelines,
          requiredFields: channel.requiredFields,
          active: channel.active,
        };
      });

      return result;
    }

    #getPresentSettings() {
      const self = this.#self;
      const { dom, options, ui } = self;
      return {
        firstLine: {
          show: true,
          titleType: "text",
          title: "",
          titleDecoration: ["bold"],
          valueType: "setting",
          value: "name",
          valueDecoration: [],
        },
        secondLine: {
          show: true,
          titleType: "text",
          title: this.#text.fields + ":",
          titleDecoration: [],
          valueType: "function",
          value: (setting) => {
            if (
              !setting.requiredFields ||
              setting.requiredFields.length === 0
            ) {
              return this.#text.fieldsNotSet;
            }

            // Получаем реальные названия полей
            const fieldNames = setting.requiredFields.map((field) => {
              if (typeof field === "object" && field.name) {
                return field.name;
              }
              const realName = this.#getFieldName(field.id || field);
              return realName;
            });

            // Ограничиваем количество отображаемых названий до 3
            fieldNames.forEach((name, index) => {
              fieldNames[index] = ui.getChips(name);
            });
            const maxDisplayCount = 3;
            if (fieldNames.length <= maxDisplayCount) {
              return fieldNames.join("");
            } else {
              const displayedNames = fieldNames.slice(0, maxDisplayCount);
              return `${displayedNames.join("")} ${ui.getChips(`+${fieldNames.length - maxDisplayCount}`)}`;
            }
          },
          valueDecoration: [],
        },
        thirdLine: {
          // Для показа менеджеров в строке с текстом, отключено
          show: false,
          titleType: "text",
          title: "",
          titleDecoration: [],
          valueType: "function",
          value: (setting) => {
            return "";
            if (!setting.managers || setting.managers.length === 0) {
              return this.#text.managersNotAssigned;
            }
            return `${setting.managers.length} ${this.#text.managersCount}`;
          },
          valueDecoration: [],
        },
        icon: {
          type: "html",
          value: `
<svg width="23" height="15" viewBox="0 0 23 15" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M0 0.93243C0 0.417463 0.417463 0 0.93243 0H22.0675C22.5825 0 22.9999 0.417463 22.9999 0.93243C22.9999 1.4474 22.5825 1.86486 22.0675 1.86486H0.93243C0.417463 1.86486 0 1.4474 0 0.93243ZM0 7.14863C0 6.63366 0.417463 6.2162 0.93243 6.2162H9.63511C10.1501 6.2162 10.5675 6.63366 10.5675 7.14863C10.5675 7.6636 10.1501 8.08106 9.63511 8.08106H0.93243C0.417463 8.08106 0 7.6636 0 7.14863ZM0 13.3648C0 12.8499 0.417463 12.4324 0.93243 12.4324H9.63511C10.1501 12.4324 10.5675 12.8499 10.5675 13.3648C10.5675 13.8798 10.1501 14.2973 9.63511 14.2973H0.93243C0.417463 14.2973 0 13.8798 0 13.3648Z" fill="#4C8BF7"/>
<path d="M22.6411 6.41344C23.0472 6.73016 23.1196 7.31608 22.8029 7.72213L17.9543 13.9383C17.7812 14.1602 17.5172 14.292 17.2359 14.2971C16.9546 14.3022 16.686 14.18 16.5051 13.9646L13.8943 10.8565C13.563 10.4622 13.6142 9.87401 14.0085 9.54279C14.4028 9.21157 14.991 9.26271 15.3222 9.65703L17.1922 11.8832L21.3324 6.57518C21.6492 6.16913 22.2351 6.09671 22.6411 6.41344Z" fill="#4C8BF7"/>
</svg>
`,
        },
      };
    }

    #createSessionToggler() {
      const self = this.#self;
      const { dom, options } = self;

      const toggler = dom.add("div");
      toggler.className = `emfy-${options.get("module")}-section-toggler`;

      let pipelinesButton = dom.add("button");
      let managersButton = dom.add("button");

      pipelinesButton.className = `emfy-${options.get("module")}-section-toggler-button ${options.get("module")}-pipelines-button active`;
      pipelinesButton.innerText = this.#text.pipelines;
      pipelinesButton.addEventListener("click", () => {
        pipelinesButton.classList.add("active");
        managersButton.classList.remove("active");
        this.showPipelineSection();
      });

      managersButton.className = `emfy-${options.get("module")}-section-toggler-button ${options.get("module")}-managers-button`;
      managersButton.innerText = this.#text.managers;
      managersButton.addEventListener("click", () => {
        pipelinesButton.classList.remove("active");
        managersButton.classList.add("active");
        this.showManagerSection();
      });

      toggler.appendChild(pipelinesButton);
      toggler.appendChild(managersButton);

      return toggler;
    }

    showManagerSection() {
      this.showSection(this.#managersSection, this.#pipelineAndFieldSection);
    }

    showPipelineSection() {
      this.showSection(this.#pipelineAndFieldSection, this.#managersSection);
    }

    showSection(enableSection, disableSection) {
      disableSection.style.opacity = "0";
      setTimeout(() => {
        disableSection.style.display = "none";
        enableSection.style.display = "grid";
        enableSection.style.opacity = "1";
      }, 300);
    }

    async #renderModalHandler(setting, updateModal) {
      // Сохраняем данные для доступа в парсере
      this.#currentModalData = {
        setting: setting
          ? this.#deepClone(setting)
          : {
              name: this.#text.newChannel,
              managers: [],
              pipelines: [],
              requiredFields: [],
              active: true,
            },
        updateModal,
        managerSelect: null,
        pipelineSelect: null,
        fieldSelect: null,
      };

      const { dom, options } = this.#self;
      const form = dom.add("div");
      form.style.cssText = "padding: 20px; max-height: 50vh; overflow-y: auto;";

      // Поле названия канала
      const nameSection = dom.add("div");
      nameSection.style.cssText = `
    height: min-content;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between; 
  `;

      const nameInput = dom.add("input");
      nameInput.type = "text";
      nameInput.placeholder = this.#currentModalData.setting.name;
      nameInput.className = `emfy-${options.get("module")}-modal-header`;

      nameInput.addEventListener("input", (e) => {
        if (this.#currentModalData) {
          this.#currentModalData.setting.name = e.target.value;
        }
      });

      const closeButton = dom.add("button");
      closeButton.className = `emfy-${options.get("module")}-close-button icon icon-modal-close`;
      closeButton.addEventListener("click", (e) => {
        e.preventDefault();
        const button = e.target;
        button
          .closest(`.emfy-${options.get("module")} .settings-modal.show.up`)
          .querySelector(".cancel-button")
          .click();
      });
      nameSection.appendChild(nameInput);
      nameSection.appendChild(closeButton);
      form.appendChild(nameSection);

      // Добавляем переключатель секций
      const toggler = this.#createSessionToggler();
      form.appendChild(toggler);
      this.#sectionToggler = toggler;

      // Секция менеджеров
      const managersSection = dom.add("div");
      managersSection.className = `emfy-${options.get("module")}-settings-section`;

      const managerText = dom.add("div");
      managerText.innerText = this.#text.managers;
      managersSection.appendChild(managerText);

      const managerSelectContainer = dom.add("div");
      managerSelectContainer.className = "manager-select-component";

      // Инициализация менеджеров
      if (this.#self.managerSelect) {
        const managerIds = (this.#currentModalData.setting.managers || []).map(
          (m) => (typeof m === "object" ? m.id.toString() : m.toString()),
        );

        const managerSelect = new this.#self.managerSelect(
          this.#self,
          {
            groups: [],
            managers: managerIds,
          },
          { groups: [], managers: [] },
        );

        $(managerSelectContainer).append(managerSelect);
        managerSelect.init();

        this.#currentModalData.managerSelect = managerSelect;
      } else {
        managerSelectContainer.innerHTML = `<div style="color: var(--palette-text-secondary); padding: 20px; text-align: center;">${this.#text.managersNotAvailable}</div>`;
      }

      managersSection.appendChild(managerSelectContainer);
      form.appendChild(managersSection);

      // Секция полей и воронок
      const pipelineAndFieldSection = dom.add("div");
      pipelineAndFieldSection.className = `emfy-${options.get("module")}-settings-section`;

      const fieldText = dom.add("div");
      fieldText.innerText = this.#text.fields;
      pipelineAndFieldSection.appendChild(fieldText);

      const fieldSelectContainer = dom.add("div");
      fieldSelectContainer.className = "field-select-component";
      fieldSelectContainer.style.cssText = `
  position: relative;
`;

      // НОВАЯ РЕАЛИЗАЦИЯ: Кастомный интерфейс выбора полей
      const customFieldSelector = this.#createCustomFieldSelector();
      fieldSelectContainer.appendChild(customFieldSelector);

      pipelineAndFieldSection.appendChild(fieldSelectContainer);

      // Секция воронок и этапов
      const pipelineText = dom.add("div");
      pipelineText.innerText = this.#text.pipelinesStages;
      pipelineAndFieldSection.appendChild(pipelineText);

      const pipelineSelectContainer = dom.add("div");
      pipelineSelectContainer.className = "pipeline-select-component";

      // Используем pipelineSelect если доступен
      if (this.#self.pipelineSelect) {
        const pipelinesData = await this.#preparePipelinesData();
        const selectedPipelines =
          this.#currentModalData.setting.pipelines || [];
        const selectedData =
          this.#convertToPipelineSelectFormat(selectedPipelines);

        const pipelineSelectHTML = this.#self.pipelineSelect.render({
          name: "channel_pipelines",
          has_pipelines: true,
          multiple: true,
          items: pipelinesData,
          sel: selectedData,
          id: `pipeline_select_${Date.now()}`,
          class_name: "channel-pipeline-select",
        });

        $(pipelineSelectContainer).append(pipelineSelectHTML);

        // Сохраняем элемент для парсинга
        this.#currentModalData.pipelineSelectElement = pipelineSelectContainer;
      } else {
        // Fallback на текущую реализацию с select2
        pipelineSelectContainer.style.cssText = "position: relative;";
        const pipelineSelectWrapper = dom.add("div");
        const pipelineSelect = dom.add("select");
        pipelineSelect.className = "pipeline-select";
        pipelineSelect.multiple = true;
        pipelineSelect.style.cssText = `
      width: 100%;
      min-height: 100px;
      padding: 8px;
      border: 1px solid var(--palette-border-default);
      border-radius: 4px;
      background: var(--palette-background-primary);
      color: var(--palette-text-primary);
    `;

        pipelineSelectWrapper.appendChild(pipelineSelect);
        pipelineSelectContainer.appendChild(pipelineSelectWrapper);

        await this.#initPipelineSelect(
          pipelineSelect,
          this.#currentModalData.setting.pipelines || [],
        );
        this.#currentModalData.pipelineSelect = pipelineSelect;
      }

      pipelineAndFieldSection.appendChild(pipelineSelectContainer);

      // Добавляем стрелку для pipeline select (как в новой версии)
      const pipelineArrow = dom.add("div");
      pipelineArrow.innerText = ">";
      pipelineArrow.style.cssText = `
    rotate: 90deg;
    cursor: pointer;
  `;

      const pipelineButtonsContainer = pipelineSelectContainer.querySelector(
        ".pipeline-select-wrapper__inner__container",
      );
      if (pipelineButtonsContainer) {
        pipelineButtonsContainer.appendChild(pipelineArrow);
        const selectDropdownButton = pipelineButtonsContainer.querySelector(
          ".pipeline-select__button-create-new-field",
        );
        if (selectDropdownButton) {
          selectDropdownButton.classList.add(
            `emfy-${options.get("module")}-select-dropdown-button`,
          );
        }
      }

      // Настройка переключения секций
      pipelineAndFieldSection.style.cssText = `
    transition: 0.3s;
  `;
      form.appendChild(pipelineAndFieldSection);

      this.#pipelineAndFieldSection = pipelineAndFieldSection;
      this.#managersSection = managersSection;

      // Скрываем секцию менеджеров по умолчанию (показываем поля и воронки)
      managersSection.style.cssText = `
    transition: 0.3s;
    display: none;
  `;

      return form;
    }

    #createCustomFieldSelector() {
      const { dom, options } = this.#self;
      const container = dom.add("div");
      container.className = `emfy-${options.get("module")}-custom-field-selector`;

      // Основной контейнер для текста и дропдауна
      const mainContainer = dom.add("div");
      mainContainer.style.cssText = `
    display: flex;
    align-items: center;
    gap: 8px;
    border: none; 
    color: var(--palette-text-primary);
    cursor: pointer;
    font-size: 14px;
    min-height: 40px;
  `;

      // Текст с выбранными полями
      const fieldsText = dom.add("span");
      fieldsText.className = `emfy-${options.get("module")}-fields-text`;
      fieldsText.style.cssText = `
    color: var(--palette-text-secondary);
  `;

      // Стрелка дропдауна
      const dropdownArrow = dom.add("span");
      dropdownArrow.textContent = ">";
      dropdownArrow.style.cssText = `
    transform: rotate(90deg);
    font-weight: bold;
    color: var(--palette-text-secondary);
  `;

      mainContainer.appendChild(fieldsText);
      mainContainer.appendChild(dropdownArrow);

      // Дропдаун меню
      const dropdownMenu = dom.add("div");
      dropdownMenu.className = `emfy-${options.get("module")}-fields-dropdown`;
      dropdownMenu.style.cssText = `
    position: fixed;
    background: var(--palette-background-default);
    border: 1px solid var(--palette-border-default);
    border-radius: 4px;
    margin-top: 4px;
    padding: 8px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  `;

      container.appendChild(mainContainer);
      container.appendChild(dropdownMenu);

      // Загружаем поля и инициализируем интерфейс
      this.#initializeCustomFieldSelector(
        container,
        mainContainer,
        fieldsText,
        dropdownMenu,
      );

      return container;
    }

    #initializeCustomFieldSelector(
      container,
      mainContainer,
      fieldsText,
      dropdownMenu,
    ) {
      const { dom } = this.#self;

      // Получаем доступные поля
      const fieldsData = this.#getDealFields();
      const selectedFieldIds = (
        this.#currentModalData.setting.requiredFields || []
      ).map((f) => (typeof f === "object" ? f.id.toString() : f.toString()));

      // Функция обновления текста полей
      const updateFieldsText = () => {
        if (selectedFieldIds.length === 0) {
          fieldsText.textContent = this.#text.choose;
          fieldsText.style.color = "var(--palette-text-secondary)";
        } else {
          const fieldNames = selectedFieldIds.map((fieldId) =>
            this.#getFieldName(fieldId, fieldsData),
          );
          fieldsText.textContent = fieldNames.join(", ");
          fieldsText.style.color = "var(--palette-text-primary)";
        }
      };

      // Функция обновления дропдаун меню
      const updateDropdownMenu = () => {
        dropdownMenu.innerHTML = "";

        // Добавляем поля из групп
        Object.values(fieldsData.groups).forEach((group) => {
          const groupHeader = dom.add("div");
          groupHeader.textContent = group.name;
          groupHeader.style.cssText = `
        font-weight: bold;
        margin-top: 8px;
        margin-bottom: 4px;
        padding: 4px 8px;
        color: var(--palette-text-primary);
        font-size: 12px;
        text-transform: uppercase;
      `;
          dropdownMenu.appendChild(groupHeader);

          group.items.forEach((field) => {
            const fieldItem = dom.add("div");
            fieldItem.className = `emfy-${this.#self.options.get("module")}-field-item`;
            fieldItem.style.cssText = `
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 6px 8px;
          border-radius: 4px;
          cursor: pointer;
          background: ${selectedFieldIds.includes(field.id) ? "var(--color-blueberry-light)" : "transparent"};
          color: var(--palette-text-primary);
          font-size: 14px;
          margin: 2px 0;
        `;

            const checkbox = dom.add("div");
            checkbox.style.cssText = `
          width: 16px;
          height: 16px;
          border: 2px solid ${selectedFieldIds.includes(field.id) ? "var(--color-blueberry)" : "var(--palette-border-default)"};
          border-radius: 2px;
          background: ${selectedFieldIds.includes(field.id) ? "var(--color-blueberry)" : "transparent"};
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          font-size: 10px;
          flex-shrink: 0;
        `;

            if (selectedFieldIds.includes(field.id)) {
              checkbox.innerHTML = "✓";
            }

            const fieldLabel = dom.add("span");
            fieldLabel.textContent = field.option;
            fieldLabel.style.cssText = `
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        `;

            fieldItem.appendChild(checkbox);
            fieldItem.appendChild(fieldLabel);

            fieldItem.addEventListener("click", (e) => {
              e.stopPropagation();
              const fieldId = field.id;
              const isSelected = selectedFieldIds.includes(fieldId);

              if (isSelected) {
                const index = selectedFieldIds.indexOf(fieldId);
                selectedFieldIds.splice(index, 1);
              } else {
                selectedFieldIds.push(fieldId);
              }

              updateFieldsText();
              updateDropdownMenu();
              this.#updateCurrentModalFields(selectedFieldIds);
            });

            dropdownMenu.appendChild(fieldItem);
          });
        });
      };

      // Обработчики событий
      mainContainer.addEventListener("click", (e) => {
        e.stopPropagation();
        const isVisible = dropdownMenu.style.display === "block";
        dropdownMenu.style.display = isVisible ? "none" : "block";
      });

      // Закрытие дропдауна при клике вне
      document.addEventListener("click", (e) => {
        if (!container.contains(e.target)) {
          dropdownMenu.style.display = "none";
        }
      });

      // Инициализация
      updateFieldsText();
      updateDropdownMenu();
    }

    // НОВЫЙ МЕТОД: Обновление полей в текущих данных модалки
    #updateCurrentModalFields(selectedFieldIds) {
      if (this.#currentModalData && this.#currentModalData.setting) {
        const fieldsData = this.#getDealFields();
        this.#currentModalData.setting.requiredFields = selectedFieldIds.map(
          (id) => ({
            id: id,
            name: this.#getFieldName(id, fieldsData),
          }),
        );
      }
    }

    // Подготовка данных для pipelineSelect
    async #preparePipelinesData() {
      await this.#ensureCacheInitialized();
      const pipelines = this.#cachedPipelines || this.#getMockPipelines();

      return Object.values(pipelines).map((pipeline) => ({
        id: pipeline.id,
        name: pipeline.name,
        statuses: Object.values(pipeline.statuses || {}).map((status) => ({
          id: status.id,
          name: status.name,
          color: status.color || "#CCCCCC",
        })),
      }));
    }

    // Преобразование выбранных данных в формат для pipelineSelect
    #convertToPipelineSelectFormat(selectedPipelines) {
      const result = {};

      selectedPipelines.forEach((item) => {
        if (!result[item.pipeline]) {
          result[item.pipeline] = [];
        }
        result[item.pipeline].push(item.stage);
      });

      return result;
    }

    async #initPipelineSelect(selectElement, selectedPipelines) {
      try {
        // Ожидаем загрузки кэша воронок
        await this.#ensureCacheInitialized();

        const pipelines = this.#cachedPipelines || this.#getMockPipelines();

        // Очищаем select
        selectElement.innerHTML = "";

        // Добавляем опцию-плейсхолдер
        const placeholderOption = document.createElement("option");
        placeholderOption.textContent = this.#text.choosePipelinesStages;
        placeholderOption.disabled = true;
        placeholderOption.selected = true;
        placeholderOption.hidden = true;
        selectElement.appendChild(placeholderOption);

        // Добавляем опции воронок и этапов
        Object.values(pipelines).forEach((pipeline) => {
          if (pipeline.statuses && Object.keys(pipeline.statuses).length > 0) {
            // Добавляем optgroup для воронки
            const optgroup = document.createElement("optgroup");
            optgroup.label = pipeline.name;

            // Добавляем этапы воронки
            Object.values(pipeline.statuses).forEach((stage) => {
              if (stage && stage.name) {
                const option = document.createElement("option");
                const optionId = `${pipeline.id}_${stage.id}`;
                option.value = optionId;
                option.textContent = `${pipeline.name} - ${stage.name}`;

                // Проверяем, выбрана ли эта опция
                const isSelected = selectedPipelines.some(
                  (p) => p.pipeline === pipeline.id && p.stage === stage.id,
                );
                if (isSelected) {
                  option.selected = true;
                  // Снимаем выделение с плейсхолдера при выборе опций
                  placeholderOption.selected = false;
                }

                optgroup.appendChild(option);
              }
            });

            selectElement.appendChild(optgroup);
          }
        });

        // Если нет воронок, показываем сообщение
        if (selectElement.options.length === 1) {
          // только плейсхолдер
          const noDataOption = document.createElement("option");
          noDataOption.textContent = this.#text.noPipelinesAvailable;
          noDataOption.disabled = true;
          noDataOption.selected = true;
          selectElement.appendChild(noDataOption);
        }

        // Сохраняем ссылку на селект воронок
        if (this.#currentModalData) {
          this.#currentModalData.pipelineSelect = selectElement;
        }

        // Инициализируем select2 если доступен
        if (typeof $.fn.select2 === "function") {
          $(selectElement).select2({
            width: "100%",
            placeholder: this.#text.choosePipelinesStages,
            allowClear: true,
            closeOnSelect: false,
          });

          // Обработчик изменения выбора для select2
          $(selectElement).on("change", () => {
            if (this.#currentModalData && this.#currentModalData.setting) {
              const selectedValues = $(selectElement).val() || [];
              this.#currentModalData.setting.pipelines = selectedValues
                .map((value) => {
                  if (value && value.includes("_")) {
                    const [pipelineId, stageId] = value.split("_");
                    const pipelineName = this.#getPipelineName(
                      parseInt(pipelineId),
                    );
                    const stageName = this.#getStageName(
                      parseInt(pipelineId),
                      parseInt(stageId),
                    );
                    return {
                      pipeline: parseInt(pipelineId),
                      stage: parseInt(stageId),
                      name: `${pipelineName} - ${stageName}`,
                    };
                  }
                  return null;
                })
                .filter(Boolean);
            }
          });
        } else {
          // Fallback для обычного select
          selectElement.addEventListener("change", () => {
            if (this.#currentModalData && this.#currentModalData.setting) {
              const selectedOptions = Array.from(selectElement.selectedOptions);
              this.#currentModalData.setting.pipelines = selectedOptions
                .map((option) => {
                  const value = option.value;
                  if (value && value.includes("_")) {
                    const [pipelineId, stageId] = value.split("_");
                    const pipelineName = this.#getPipelineName(
                      parseInt(pipelineId),
                    );
                    const stageName = this.#getStageName(
                      parseInt(pipelineId),
                      parseInt(stageId),
                    );
                    return {
                      pipeline: parseInt(pipelineId),
                      stage: parseInt(stageId),
                      name: `${pipelineName} - ${stageName}`,
                    };
                  }
                  return null;
                })
                .filter(Boolean);
            }
          });
        }
      } catch (error) {
        console.error("Error initializing pipeline select:", error);

        // Показываем сообщение об ошибке
        selectElement.innerHTML = "";
        const errorOption = document.createElement("option");
        errorOption.textContent = this.#text.errorLoadingPipelines;
        errorOption.disabled = true;
        errorOption.selected = true;
        selectElement.appendChild(errorOption);
      }
    }

    #parseModalDataHandler(modalElement) {
      if (!this.#currentModalData) {
        return {
          name: this.#text.newChannel,
          managers: [],
          pipelines: [],
          requiredFields: [],
          active: true,
        };
      }

      const {
        setting,
        managerSelect,
        pipelineSelect,
        fieldSelect,
        pipelineSelectElement,
      } = this.#currentModalData;

      const result = {
        name: setting?.name || this.#text.newChannel,
        managers: [],
        pipelines: [],
        requiredFields: setting?.requiredFields || [], // Берем напрямую из setting
        active: setting?.active !== undefined ? setting.active : true,
      };

      // Получаем данные менеджеров
      if (managerSelect && managerSelect.selected) {
        result.managers = managerSelect.selected.managers.map((id) => ({
          id: parseInt(id),
          name: this.#getManagerName(id),
        }));
      } else if (setting.managers) {
        result.managers = setting.managers.map((m) => ({
          id: typeof m === "object" ? m.id : parseInt(m),
          name: typeof m === "object" ? m.name : this.#getManagerName(m),
        }));
      }

      // Получаем данные воронок
      if (pipelineSelectElement) {
        // Парсим данные из pipelineSelect компонента
        result.pipelines = this.#parsePipelineSelectData(pipelineSelectElement);
      } else if (pipelineSelect) {
        // Fallback: парсим из select2
        let selectedValues = [];
        if (
          typeof $.fn.select2 === "function" &&
          $(pipelineSelect).data("select2")
        ) {
          selectedValues = $(pipelineSelect).val() || [];
        } else {
          const selectedOptions = Array.from(pipelineSelect.selectedOptions);
          selectedValues = selectedOptions.map((option) => option.value);
        }

        result.pipelines = selectedValues
          .map((value) => {
            if (value && value.includes("_")) {
              const [pipelineId, stageId] = value.split("_");
              const pipelineName = this.#getPipelineName(parseInt(pipelineId));
              const stageName = this.#getStageName(
                parseInt(pipelineId),
                parseInt(stageId),
              );
              return {
                pipeline: parseInt(pipelineId),
                stage: parseInt(stageId),
                name: `${pipelineName} - ${stageName}`,
              };
            }
            return null;
          })
          .filter(Boolean);
      } else if (setting.pipelines) {
        result.pipelines = setting.pipelines;
      }

      // Получаем данные полей (уже обновлены через кастомный интерфейс)
      if (setting.requiredFields) {
        result.requiredFields = setting.requiredFields;
      }

      this.#currentModalData = null;
      return result;
    }

    #parsePipelineSelectData(pipelineSelectElement) {
      const result = [];

      // Находим все выбранные чекбоксы статусов
      const selectedCheckboxes = pipelineSelectElement.querySelectorAll(
        'input[type="checkbox"][name^="filter[pipe]"]:checked',
      );

      selectedCheckboxes.forEach((checkbox) => {
        const pipelineId = checkbox.getAttribute("data-pipeline-id");
        const statusId = checkbox.value;

        if (pipelineId && statusId) {
          const pipelineName = this.#getPipelineName(parseInt(pipelineId));
          const stageName = this.#getStageName(
            parseInt(pipelineId),
            parseInt(statusId),
          );

          result.push({
            pipeline: parseInt(pipelineId),
            stage: parseInt(statusId),
            name: `${pipelineName} - ${stageName}`,
          });
        }
      });

      return result;
    }

    #onSettingsUpdate(instanceId, sortableSettings) {
      const instance = this.#instances.get(instanceId);
      if (instance) {
        // Обновляем данные каналов
        const sortableData = sortableSettings.getSettings();
        instance.channels = this.#convertFromSortableFormat(sortableData);
      }
    }

    #getPipelineName(pipelineId) {
      const pipelines = this.#cachedPipelines || this.#getMockPipelines();
      return (
        pipelines[pipelineId]?.name || `${this.#text.pipeline} ${pipelineId}`
      );
    }

    #getStageName(pipelineId, stageId) {
      const pipelines = this.#cachedPipelines || this.#getMockPipelines();
      return (
        pipelines[pipelineId]?.statuses?.[stageId]?.name ||
        `${this.#text.stage} ${stageId}`
      );
    }

    #getManagerName(managerId) {
      const managers = APP?.constant("managers") || {};
      const manager = managers[managerId];
      return manager?.title || `${this.#text.manager} ${managerId}`;
    }

    #getMockPipelines() {
      return {
        1: {
          id: 1,
          name: this.#text.mainPipeline,
          statuses: {
            1: { id: 1, name: this.#text.primaryContact },
            2: { id: 2, name: this.#text.negotiations },
            3: { id: 3, name: this.#text.decisionMaking },
          },
        },
        2: {
          id: 2,
          name: this.#text.additionalPipeline,
          statuses: {
            4: { id: 4, name: this.#text.analysis },
            5: { id: 5, name: this.#text.closing },
          },
        },
      };
    }

    #getDealFields() {
      if (this.#fieldsCache) {
        return this.#fieldsCache;
      } else {
        const mockFields = {
          groups: {
            1: {
              id: 1,
              name: this.#text.baseFields,
              items: [
                { id: "budget", option: this.#text.baseFieldBudget, group: 1 },
                { id: "period", option: this.#text.baseFieldPeriod, group: 1 },
              ],
              items_ids: ["budget", "period"],
            },
            2: {
              id: 2,
              name: this.#text.customFields,
              items: [
                {
                  id: "contact",
                  option: this.#text.baseFieldContact,
                  group: 2,
                },
                { id: "source", option: this.#text.baseFieldSource, group: 2 },
              ],
              items_ids: ["contact", "source"],
            },
          },
          items: {
            budget: {
              id: "budget",
              option: this.#text.baseFieldBudget,
              group: 1,
            },
            period: {
              id: "period",
              option: this.#text.baseFieldPeriod,
              group: 1,
            },
            contact: {
              id: "contact",
              option: this.#text.baseFieldContact,
              group: 2,
            },
            source: {
              id: "source",
              option: this.#text.baseFieldSource,
              group: 2,
            },
          },
        };
        return mockFields;
      }
    }

    #getFieldName(fieldId, fields) {
      if (fields && fields.items && fields.items[fieldId]) {
        return fields.items[fieldId].option || fieldId;
      }
      return fieldId;
    }

    init() {
      this.#text.newChannel =
        this.#self.i18n("ChannelManager.newChannel") || "Новый канал";
      this.#text.channel = this.#self.i18n("ChannelManager.channel") || "Канал";
      this.#text.delete = this.#self.i18n("ChannelManager.delete") || "Удалить";
      this.#text.edit =
        this.#self.i18n("ChannelManager.edit") || "Редактировать";
      this.#text.managers =
        this.#self.i18n("ChannelManager.managers") || "Менеджеры";
      this.#text.pipelines =
        this.#self.i18n("ChannelManager.pipelines") || "Воронки и этапы";
      this.#text.requiredFields =
        this.#self.i18n("ChannelManager.requiredFields") || "Обязательные поля";
      this.#text.addChannel =
        this.#self.i18n("ChannelManager.addChannel") || "Добавить канал";
      this.#text.title =
        this.#self.i18n("ChannelManager.title") || "Настройка каналов";
      this.#text.channelList =
        this.#self.i18n("ChannelManager.channelList") || "Список каналов";
      this.#text.createChannel =
        this.#self.i18n("ChannelManager.createChannel") || "Создать канал";
      this.#text.save = this.#self.i18n("ChannelManager.save") || "Сохранить";
      this.#text.cancel = this.#self.i18n("ChannelManager.cancel") || "Отмена";
      this.#text.noChannels =
        this.#self.i18n("ChannelManager.noChannels") || "Нет созданных правил.";
      this.#text.noChannelsDescription =
        this.#self.i18n("ChannelManager.noChannelsDescription") ||
        "Нажмите на кнопку выше, чтобы добавить правило.";
      this.#text.requiredFieldsDescription =
        this.#self.i18n("ChannelManager.requiredFieldsDescription") ||
        "Укажите в правилах поля, без заполнения которых сделку нельзя будет сдвинуть.\nОпределите воронки и этапы, когда они становятся обязательными.";
      this.#text.choosePipelinesStages =
        this.#self.i18n("ChannelManager.choosePipelinesStages") ||
        "Выберите воронки и этапы";
      this.#text.noPipelinesAvailable =
        this.#self.i18n("ChannelManager.noPipelinesAvailable") ||
        "Нет доступных воронок";
      this.#text.pipelinesStages =
        this.#self.i18n("ChannelManager.pipelinesStages") || "Воронки и этапы";
      this.#text.fields = this.#self.i18n("ChannelManager.fields") || "Поля";
      this.#text.choose = this.#self.i18n("ChannelManager.choose") || "выбрать";
      this.#text.managersNotAvailable =
        this.#self.i18n("ChannelManager.managersNotAvailable") ||
        "Компонент выбора менеджеров не доступен";
      this.#text.baseFieldsGroup =
        this.#self.i18n("ChannelManager.baseFieldsGroup") || "Базовые поля";
      this.#text.customFields =
        this.#self.i18n("ChannelManager.customFields") || "Доп. поля";
      this.#text.fieldsNotSet =
        this.#self.i18n("ChannelManager.fieldsNotSet") || "Не заданы";
      this.#text.managersNotAssigned =
        this.#self.i18n("ChannelManager.managersNotAssigned") || "Не назначены";
      this.#text.managersCount =
        this.#self.i18n("ChannelManager.managersCount") || "менеджеров";
      this.#text.errorLoadingPipelines =
        this.#self.i18n("ChannelManager.errorLoadingPipelines") ||
        "Ошибка загрузки воронок";
      this.#text.mainPipeline =
        this.#self.i18n("ChannelManager.mainPipeline") || "Основная воронка";
      this.#text.additionalPipeline =
        this.#self.i18n("ChannelManager.additionalPipeline") || "Доп. воронка";
      this.#text.primaryContact =
        this.#self.i18n("ChannelManager.primaryContact") || "Первичный контакт";
      this.#text.negotiations =
        this.#self.i18n("ChannelManager.negotiations") || "Переговоры";
      this.#text.decisionMaking =
        this.#self.i18n("ChannelManager.decisionMaking") || "Принятие решения";
      this.#text.analysis =
        this.#self.i18n("ChannelManager.analysis") || "Анализ";
      this.#text.closing =
        this.#self.i18n("ChannelManager.closing") || "Закрытие";
      this.#text.pipeline =
        this.#self.i18n("ChannelManager.pipeline") || "Воронка";
      this.#text.stage = this.#self.i18n("ChannelManager.stage") || "Этап";
      this.#text.manager =
        this.#self.i18n("ChannelManager.manager") || "Менеджер";
      this.#text.baseFields = this.#self.i18n("ChannelManager.baseFields") || {
        name: "Название",
        budget: "Бюджет",
        pipeline: "Воронка",
        stage: "Этап",
        responsible: "Ответственный",
        tags: "Теги",
        lossReason: "Причина отказа",
        createdAt: "Дата создания",
        updatedAt: "Дата изменения",
        closedAt: "Дата закрытия",
        period: "Срок",
        contact: "Контактное лицо",
        source: "Источник",
      };

      this.#fieldsCachePromise = this.#getFieldsCache();
      this.#pipelineCachePromise = this.#getPipelineCache();
    }
  };
});
