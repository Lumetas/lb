define(["jquery", "lib/components/base/modal"], function ($, Modal) {
  /**
   * Модуль для обработки запросов
   */
  return class QuickTimeStorage {
    #inProgress = new Map();
    #cache = new Map();
    #cacheTime = 30000; // 30 сек
    #apiV4Timestamps = new Set();
    #rateLimitLock = false;
    #rateLimitQueue = [];
    #lastRequestTime = 0;
    #requestDelay = 250; // 250 мс задержка между запросами
    #dbReady = null;
    #openDB = null;

    constructor() {
      if (window.indexedDB) {
        this.#dbReady = this.#openStorage();
      }

      if (APP.constant("emfy_quick_time_storage_1.3"))
        return APP.constant("emfy_quick_time_storage_1.3");

      APP.constant("emfy_quick_time_storage_1.3", this);

      return this;
    }

    async fetch(
      url,
      params = {},
      typeData = "json",
      retries = 1,
      noCache = false,
    ) {
      if (!url) return null;

      const method = params.method || "GET";
      const body = params.body || "";

      const cacheKey = this.#generateCacheKey(url, method, body, typeData);

      if (!noCache) {
        // Проверяем, есть ли ответ в кэше в объекте
        if (this.#cache.has(cacheKey)) return this.#cache.get(cacheKey);
        // Проверяем есть ли такой же запрос в ожидании в объекте
        if (this.#inProgress.has(cacheKey))
          return this.#inProgress.get(cacheKey);

        if (window.indexedDB) {
          const lastQueryTimestamp = await this.#getLastQueryTimestamp();

          if (Date.now() - lastQueryTimestamp > this.#cacheTime) {
            await this.#clearInProgressStorage();
            await this.#clearCacheStorage();
          }

          const completeCacheValue = await this.#getStorageCacheValue(cacheKey);
          const processCacheValueExists =
            await this.#getInProgressValue(cacheKey);

          // Кэш в хранилище
          if (completeCacheValue) {
            return completeCacheValue;
          }
          if (processCacheValueExists) {
            return await new Promise((resolve, reject) => {
              setTimeout(async () => {
                const response = await this.fetch(
                  url,
                  params,
                  typeData,
                  retries,
                  noCache,
                );
                resolve(response);
              }, 1000);
            });
          }
        }
      }

      // Создаем промис с запросом и возвращаем его
      const promise = this.#makeRequestWithRetries(
        url,
        params,
        typeData,
        cacheKey,
        retries,
        noCache,
      );

      this.#inProgress.set(cacheKey, promise);
      if (window.indexedDB) await this.#setInProgressValue(cacheKey);

      return promise;
    }

    // Генерируем ключ
    #generateCacheKey(url, method, body, typeData) {
      const serializedBody =
        typeof body === "string"
          ? body
          : JSON.stringify(this.#sortObjectKeys(body));
      return `${method}:${url}:${typeData}:${serializedBody}`;
    }

    // Рекурсивная сортировка ключей объекта, чтобы одинаковые по содержимому объекты выдавали одинаковые строки
    #sortObjectKeys(obj) {
      if (obj === null || typeof obj !== "object" || Array.isArray(obj)) {
        return obj; // массивы и примитивы не трогаем
      }

      return Object.keys(obj)
        .sort()
        .reduce((res, key) => {
          res[key] = this.#sortObjectKeys(obj[key]);
          return res;
        }, {});
    }

    // Обертка, чтобы вызвать запрос повторно при ошибке
    async #makeRequestWithRetries(
      url,
      params,
      typeData,
      cacheKey,
      retries,
      noCache,
    ) {
      let attempt = 0;

      while (attempt < retries) {
        try {
          const result = await this.#makeRequestWithRateLimit(
            url,
            params,
            typeData,
            cacheKey,
            retries,
            noCache,
          );
          return result;
        } catch (error) {
          attempt++;
          const isLastAttempt = attempt >= retries;

          if (isLastAttempt) {
            throw error;
          }

          // Увеличиваем время до следующего запроса
          await new Promise((res) =>
            setTimeout(res, 100 * Math.pow(2, attempt)),
          );
        }
      }
    }

    // Метод для запросов с проверкой очереди
    async #makeRequestWithRateLimit(
      url,
      params,
      typeData,
      cacheKey,
      retries,
      noCache,
    ) {
      try {
        // Проверка входных параметров
        if (!url || typeof url !== "string") {
          throw new Error("Invalid URL parameter");
        }
        if (
          !typeData ||
          ![
            "json",
            "text",
            "blob",
            "arrayBuffer",
            "formData",
            "clone",
            "body",
          ].includes(typeData)
        ) {
          throw new Error("Invalid typeData parameter");
        }

        await this.#enforceRateLimit();
        this.#recordApiV4RequestTime();

        // Таймаут запроса
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 25000);
        // Обновляем данные timestamp
        if (window.indexedDB) await this.#setQueryTimestamp();

        try {
          this.#lastRequestTime = Date.now();
          const response = await fetch(url, {
            ...params,
            signal: controller.signal,
          });

          clearTimeout(timeout);

          // Обработка HTTP ошибок
          if (!response.ok) {
            let errorDetails = `HTTP error ${response.status}`;
            try {
              const errorBody = await response.text();
              if (errorBody) errorDetails += `: ${errorBody}`;
            } catch (e) {
              console.warn("Failed to read error response body", e);
            }

            if (response.status === 429) {
              throw new Error(`Rate limit exceeded: ${errorDetails}`);
            } else if (response.status >= 500) {
              throw new Error(`Server error: ${errorDetails}`);
            } else {
              throw new Error(`Request failed: ${errorDetails}`);
            }
          }
          if (response.status === 204) {
            return null;
          }
          // Получение данных
          let data;

          if (typeData === "body") {
            data = response.body;
          } else {
            try {
              data = await response[typeData]();
            } catch (parseError) {
              throw new Error(
                `Failed to parse response as ${typeData}: ${parseError.message}`,
              );
            }
          }

          // Кэширование
          if (cacheKey) {
            this.#cache.set(cacheKey, data);
            if (window.indexedDB)
              await this.#setStorageCacheValue(cacheKey, data);
            setTimeout(async () => {
              this.#cache.delete(cacheKey);
              if (window.indexedDB)
                await this.#unsetStorageCacheValue(cacheKey);
            }, this.#cacheTime);
          }

          return data;
        } catch (error) {
          clearTimeout(timeout); // Очищаем таймаут в случае ошибки
          throw error;
        }
      } catch (error) {
        console.error("Request failed:", {
          url,
          params,
          error: error.message,
          stack: error.stack,
        });

        // Пробрасываем ошибку дальше с дополнительным контекстом
        throw new Error(`Failed to make request to ${url}: ${error.message}`);
      } finally {
        if (cacheKey) {
          this.#inProgress.delete(cacheKey);
          if (window.indexedDB) {
            await this.#unsetInProgressValue(cacheKey);
            setTimeout(async () => {
              const localStorageInProgress =
                await this.#checkInProgressRecords();
              const queryTimestamp = await this.#getLastQueryTimestamp();

              if (
                localStorageInProgress &&
                Date.now() - queryTimestamp > 60000
              ) {
                await this.#clearInProgressStorage();
                await this.#clearCacheStorage();
              }
            }, 60000);
          }
        }
      }
    }

    // Добавляем штамп времени + добавляем очистку через 1 сек
    #recordApiV4RequestTime() {
      const timestamp = Date.now();
      this.#apiV4Timestamps.add(timestamp);
      setTimeout(() => {
        this.#apiV4Timestamps.delete(timestamp);
      }, 1000);
    }
    // Промис ожидания на основе очереди
    async #enforceRateLimit() {
      return new Promise((resolve, reject) => {
        this.#rateLimitQueue.push({ resolve, reject });
        this.#processRateLimitQueue();
      });
    }
    // Обработчик очереди
    async #processRateLimitQueue() {
      // Не даем создавать несколько обработчиков очереди
      if (this.#rateLimitLock || this.#rateLimitQueue.length === 0) {
        return;
      }
      let queryDelay = Date.now();
      this.#rateLimitLock = true;
      // В цикле проверяем количество запросов за послекднюю секунду и резолвим промисы из очереди пока она не опустеет
      while (this.#rateLimitQueue.length > 0) {
        try {
          const timestampDiff = Date.now() - queryDelay;
          // если временной промежуток больше задержки, то достаем промис и выполняем его
          if (timestampDiff > this.#requestDelay) {
            const { resolve } = this.#rateLimitQueue.shift();
            resolve();
            queryDelay = Date.now();

            continue;
          }
          // добавляем оставшееся время задержки мс перед выполнением следующего цикла, если мы не трогали очередь
          await new Promise((resolve) =>
            setTimeout(resolve, this.#requestDelay - timestampDiff),
          );
        } catch (error) {
          const { reject } = this.#rateLimitQueue.shift();
          reject(error);
        }
      }

      this.#rateLimitLock = false;
    }

    /**
     * Открытие хранилища IndexedDB
     */
    async #openStorage() {
      return new Promise((resolve, reject) => {
        const db = indexedDB.open("emfy_quick_time_storage", 1);

        db.onupgradeneeded = (event) => {
          const openDB = event.target.result;
          if (!openDB.objectStoreNames.contains("emfy_storage_cache")) {
            openDB.createObjectStore("emfy_storage_cache", {
              keyPath: "cacheKey",
            });
          }
          if (!openDB.objectStoreNames.contains("emfy_storage_in_progress")) {
            openDB.createObjectStore("emfy_storage_in_progress", {
              keyPath: "cacheKey",
            });
          }
          if (!openDB.objectStoreNames.contains("emfy_storage_timestamp")) {
            openDB.createObjectStore("emfy_storage_timestamp", {
              keyPath: "id",
            });
          }
        };

        db.onerror = (event) => {
          console.error("Ошибка открытия базы данных: ", event.target.error);
          reject(event.target.error);
        };

        db.onsuccess = (event) => {
          this.#openDB = event.target.result;
          resolve(this.#openDB);
        };
      });
    }

    /**
     * Получение данных из хранилища emfy_storage_cache
     * @param {string} cacheKey Ключ для проверки информации в хранилище
     * @returns {Promise} Возвращает данные из хранилища или null
     */
    async #getStorageCacheValue(cacheKey) {
      const openDB = await this.#dbReady;
      return new Promise((resolve, reject) => {
        const transaction = openDB.transaction(
          "emfy_storage_cache",
          "readonly",
        );
        const storageCache = transaction.objectStore("emfy_storage_cache");
        const request = storageCache.get(cacheKey);

        request.onsuccess = () => {
          if (request.result !== undefined) {
            resolve(request.result.value);
          } else {
            resolve(null);
          }
        };

        request.onerror = () => {
          console.log("emfy_storage_cache. Ошибка чтения: ", request.error);
          reject(null);
        };
      });
    }

    /**
     * Запись данных в хранилище кэша
     * @param {string} cacheKey Ключ для записи информации в хранилище
     * @param {string} data Данные ответа для кэширования
     */
    async #setStorageCacheValue(cacheKey, data) {
      const openDB = await this.#dbReady;
      const transaction = openDB.transaction("emfy_storage_cache", "readwrite");
      const storageCache = transaction.objectStore("emfy_storage_cache");
      const request = storageCache.add({ cacheKey: cacheKey, value: data });

      request.onerror = () => {
        console.log("emfy_storage_cache. Ошибка записи: ", request.error);
      };
    }

    /**
     * Удаление записи в хранилище по ключу
     * @param {string} cacheKey Ключ кэшированных данных
     */
    async #unsetStorageCacheValue(cacheKey) {
      const openDB = await this.#dbReady;
      const transaction = openDB.transaction("emfy_storage_cache", "readwrite");
      const storageCache = transaction.objectStore("emfy_storage_cache");
      const request = storageCache.delete(cacheKey);

      request.onerror = () => {
        console.log("emfy_storage_cache. Ошибка удаления: ", request.error);
      };
    }

    /**
     * Очистка хранилища emfy_storage_cache
     */
    async #clearCacheStorage() {
      const openDB = await this.#dbReady;
      const transaction = openDB.transaction("emfy_storage_cache", "readwrite");
      const storageInProgress = transaction.objectStore("emfy_storage_cache");
      const request = storageInProgress.clear();

      request.onerror = () => {
        console.log(
          "emfy_storage_cache. Ошибка очистки хранилища: ",
          request.error,
        );
      };
    }

    /**
     * Добавление ключа в хранилище emfy_storage_in_progress
     * @param {string} cacheKey Принимает ключ для добавления информации в хранилище
     */
    async #setInProgressValue(cacheKey) {
      const openDB = await this.#dbReady;
      const transaction = openDB.transaction(
        "emfy_storage_in_progress",
        "readwrite",
      );
      const storageInProgress = transaction.objectStore(
        "emfy_storage_in_progress",
      );
      const request = storageInProgress.add({
        cacheKey: cacheKey,
        value: cacheKey,
      });

      request.onerror = () => {
        console.log(
          "emfy_storage_in_progress. Ошибка добавления: ",
          request.error,
        );
      };
    }

    /**
     * Получение промиса из хранилища emfy_storage_in_progress
     * @param {string} cacheKey Принимает ключ для получения информации из хранилища
     * @returns {Promise} Сохраненный промис
     */
    async #getInProgressValue(cacheKey) {
      const openDB = await this.#dbReady;
      return new Promise((resolve, reject) => {
        const transaction = openDB.transaction(
          "emfy_storage_in_progress",
          "readonly",
        );
        const storageInProgress = transaction.objectStore(
          "emfy_storage_in_progress",
        );
        const request = storageInProgress.get(cacheKey);

        request.onsuccess = () => {
          if (request.result !== undefined) {
            resolve(request.result.value);
          } else {
            resolve(null);
          }
        };

        request.onerror = () => {
          reject(request.error);
        };
      });
    }

    /**
     * Удаление записи из хранилища emfy_storage_in_progress
     * @param cacheKey Ключ для удаления значения
     */
    async #unsetInProgressValue(cacheKey) {
      const openDB = await this.#dbReady;
      const transaction = openDB.transaction(
        "emfy_storage_in_progress",
        "readwrite",
      );
      const storageInProgress = transaction.objectStore(
        "emfy_storage_in_progress",
      );
      const request = storageInProgress.delete(cacheKey);

      request.onerror = () => {
        console.log(
          "Ошибка удаления из хранилища emfy_storage_in_progress: ",
          request.error,
        );
      };
    }

    /**
     * Проверка, есть ли записи в хранилище
     * @returns {Promise} Возвращает логическое значение присутствия или отсутствия записей в хранилище
     */
    async #checkInProgressRecords() {
      const openDB = await this.#dbReady;
      return new Promise((resolve, reject) => {
        const transaction = openDB.transaction(
          "emfy_storage_in_progress",
          "readonly",
        );
        const storageInProgress = transaction.objectStore(
          "emfy_storage_in_progress",
        );
        const request = storageInProgress.count();

        request.onsuccess = () => {
          resolve(!!request.result);
        };

        request.onerror = () => {
          console.log(
            "inProgress. Ошибка получения количества записей в хранилище: ",
            request.error,
          );
          reject(null);
        };
      });
    }

    /**
     * Очистка хранилища emfy_storage_in_progress
     */
    async #clearInProgressStorage() {
      const openDB = await this.#dbReady;
      const transaction = openDB.transaction(
        "emfy_storage_in_progress",
        "readwrite",
      );
      const storageInProgress = transaction.objectStore(
        "emfy_storage_in_progress",
      );
      const request = storageInProgress.clear();

      request.onerror = () => {
        console.log(
          "emfy_storage_in_progress. Ошибка очистки хранилища: ",
          request.error,
        );
      };
    }

    /**
     * Возвращает последний сохраненный Timestamp
     * @returns {Promise} Сохраненное значение timestamp
     */
    async #getLastQueryTimestamp() {
      const openDB = await this.#dbReady;
      return new Promise((resolve, reject) => {
        const transaction = openDB.transaction(
          "emfy_storage_timestamp",
          "readonly",
        );
        const timestamp = transaction.objectStore("emfy_storage_timestamp");
        const request = timestamp.get(0);

        request.onsuccess = () => {
          if (request.result) {
            resolve(request.result.value);
          } else {
            resolve(null);
          }
        };

        request.onerror = () => {
          console.log("Ошибка чтения Timestamp: ", request.error);
          reject(null);
        };
      });
    }

    /**
     * Устанавливает Timestamp запроса
     */
    async #setQueryTimestamp() {
      const oldQueryTimestamp = await this.#getLastQueryTimestamp();
      const timestampValue = Date.now();
      if (oldQueryTimestamp && oldQueryTimestamp > timestampValue) return;
      const openDB = await this.#dbReady;
      const transaction = openDB.transaction(
        "emfy_storage_timestamp",
        "readwrite",
      );
      const timestamp = transaction.objectStore("emfy_storage_timestamp");
      const request = timestamp.put({ id: 0, value: timestampValue });

      request.onerror = () => {
        console.log("Ошибка записи timestamp: ", request.error);
      };
    }
  };
});
